defineVariable(int, n);
defineVariable(int, m);
defineVariable(int, i);
defineVariable(int, j);
defineVariable(int, l);
defineVariable(int, current_day);
defineVariable(int, processing_day);
defineVariable(Building, building);
defineVariable(Building, building2);
defineVariable(Vehicle, vehicle);
defineVariable(float, value);
defineVariable(float, price);
defineVariable(float, factor);
defineVariable(float, price_inertia);
defineVariable(int, population);
defineVariable(float, services);
defineVariable(int, services_int);
defineVariable(float, demand);
defineVariable(float, demand_total);
defineVariable(float, demand_total_civics);
defineVariable(float, demand_total_vehicles);
defineVariable(float, demand_vehicles);
defineVariable(float, vehicle_cost);
defineVariable(float, supply);
defineVariable(float, supply_cache);
defineVariable(float, supply_cache_capacity);
defineVariable(float, difference);
defineVariable(int, money_rub);
defineVariable(int, money_usd);
defineVariable(int, money_rub_add);
defineVariable(int, money_usd_add);
defineVariable(float, current_price_rub);
defineVariable(float, current_price_usd);
defineVariable(int, is_active);
defineVariable(int, rub_sum);
defineVariable(int, usd_sum);
defineVariable(int, rub_sum2);
defineVariable(int, usd_sum2);
defineVariable(float, game_time);
defineVariable(float, game_time_prev);
defineVariable(float, time_factor);
defineVariable(int, window_id);
defineVariable(int, window_exists);
defineVariable(Window, window);
defineVariable(int, clicked_object_id);
defineArray(char[500], text);
defineVariable(char, NEWLINE);

// Worker for which we are computing the fee
defineVariable(Person, worker);
defineVariable(int, worker_id);
// Education multiplier of generated services.
defineVariable(float, service_scale);

defineVariable(int, random_is_fire);
defineVariable(int, random_building_id);
defineVariable(vec3, vector);
defineVariable(StatRecord, stat_record);

defineVariable(GameSetting, game);

defineFunction(CalculateVehicleDemand, float)
{
	Vehicle_GetNumberOfVehicles(m);
	demand_vehicles = 0.0;
	for (i=0, i<m, i=i+1)
	{
		vehicle.GetDataByIndex(i);
		vehicle_cost = 0.0;
		if(vehicle.nTransportType ? RESOURCE_TRANSPORT_PASSANGER)
		{
			//for passenger vehicles, the cost is determined per 10 passengers
			vehicle_cost = vehicle.fResourceCapacity / 10.0;
		}
		elseif(vehicle.nTransportType > -1 & vehicle.nTransportType < RESOURCE_TRANSPORT_NUM)
		{
			//for freight vehicles, the cost is determined per 1 t
			vehicle_cost = vehicle.fResourceCapacity;
		}

		// Set road vehicle cost based on VEHICLESKILL
		if (vehicle.nVehicleType > 0 & vehicle.nVehicleType < 3)
		{
            if(vehicle.nSkill[0] ? VEHICLESKILL_SEEDING)
            {
                vehicle_cost = BASE_COST_SEEDING;
            }
            elseif(vehicle.nSkill[0] ? VEHICLESKILL_HARVESTING)
            {
                vehicle_cost = BASE_COST_HARVESTING;
            }
            elseif(vehicle.nSkill[0] ? VEHICLESKILL_SNOWPLOW)
            {
                vehicle_cost = BASE_COST_SNOWPLOWING;
            }
            elseif(vehicle.nSkill[0] ? VEHICLESKILL_PERSONAL)
            {
                vehicle_cost = BASE_COST_PERSONAL;
            }
            else()
            {
            // Finally, if no skill set by capacity
            vehicle_cost = BASE_COST_ROAD + vehicle_cost * COST_ROAD_FACTOR;
            }
        }

		//trains
		elseif(vehicle.nVehicleType < 6)
		{
			vehicle_cost = vehicle_cost + BASE_COST_RAIL + COST_RAIL_FACTOR * vehicle_cost;
		}
		//ships
		elseif(vehicle.nVehicleType ? VEHICLETYPE_SHIP)
		{
			vehicle_cost = vehicle_cost + BASE_COST_SHIP + COST_SHIP_FACTOR * vehicle_cost;
		}
		//planes, helicopters
		elseif(vehicle.nVehicleType ? VEHICLETYPE_AIRPLANE | vehicle.nVehicleType ? VEHICLETYPE_HELICOPTER)
		{
			vehicle_cost = vehicle_cost + BASE_COST_AIR + COST_AIR_FACTOR * vehicle_cost;
		}

		//if the vehicle is idle in a depot, it doesn't need many services
        if(vehicle.nBuilding_CurrentID ? vehicle.nBuilding_HomeWorkplaceID)
        {
            vehicle_cost = vehicle_cost * VEHICLE_IDLE_COST;
        }

		demand_vehicles = demand_vehicles + vehicle_cost;
	}
	return(demand_vehicles);
}

defineFunction(CalculateCivicDemand, int)
{
 	population = 0;
	for (i=0, i<n, i=i+1)
	{
		building.GetDataByIndex(i);
		if(building.nType ? BUILDINGTYPE_LIVING & building.fPercFinished > 0.9999)
		{
			Building_IsOldTownActive(i, is_active);
			population = population + is_active * is_active * building.nWorkersNum;
		}
	}
	demand = 0;
	if(!(population > GRACE_CITIZENS))
	{
		demand = population * INTERNAL_DEMAND_FACTOR * GRACE_FACTOR;
	}
	else()
	{
		demand = INTERNAL_DEMAND_FACTOR * (GRACE_CITIZENS * GRACE_FACTOR + population - GRACE_CITIZENS);
	}

	return(demand);
}

defineFunction(CalculateSupply, int)
{
	supply = 0;
	for (i=0, i<n, i=i+1)
	{
		services = 0.0;
		building.GetDataByIndex(i);

		if (!(building.nSubType ? BUILDINGSUBTYPE_ROAD) & building.fPercFinished > 0.9999)
		{
		    if(building.nType ? BUILDINGTYPE_CITYHALL)
            {
                // For each worker currently in the building, add some services
                for (j=0, j<building.nWorkersNum, j=j+1)
                {
                    // Obtain the worker
                    Building_Workers_GetID(i, j, worker_id);
                    worker.GetDataByIndex(worker_id);

                    //  The money we get from uneducated workers is diminished
                    //  while the number of educated is increased
                    service_scale = PRIMARY_ED_FACTOR;
                    if (worker.fEducation>1.999) {
                        service_scale = UNIVERSITY_ED_FACTOR;
                    }
                    services = services + service_scale;
                }
            }

            if(building.nType ? BUILDINGTYPE_UNIVERSITY & building.nSubType ? BUILDINGSUBTYPE_SOVIET)
            {
                for (j=0, j<building.nWorkersNum, j=j+1)
                {
                    Building_Workers_GetID(i, j, worker_id);
                    worker.GetDataByIndex(worker_id);
                    if (worker.bWorkplaceAsProfesor ? 1) {
                        services = services + HQ_FACTOR;
                    }
                }
            }

            if(building.nType ? BUILDINGTYPE_SECRET_POLICE & building.nVehiclesWorkingNum < 1)
            {
                // Only count this building towards supply if it has no vehicles to perform duties with
                // For each worker currently in the building, add some services
                for (j=0, j<building.nWorkersNum, j=j+1)
                {
                    // Obtain the worker
                    Building_Workers_GetID(i, j, worker_id);
                    worker.GetDataByIndex(worker_id);

                    //  The money we get from uneducated workers is diminished
                    //  while the number of educated is increased
                    service_scale = PRIMARY_ED_FACTOR;
                    if (worker.fEducation>1.999) {
                        service_scale = UNIVERSITY_ED_FACTOR;
                    }
                    services = services + service_scale;
                }
            }

            if (VEHICLE_DIFFICULTY > 0.0 & building.nType ? BUILDINGTYPE_AIRPLANE_TOWER)
            {
                // For each worker currently in the building, add some services
                for (j=0, j<building.nWorkersNum, j=j+1)
                {
                    // Obtain the worker
                    Building_Workers_GetID(i, j, worker_id);
                    worker.GetDataByIndex(worker_id);

                    //  The money we get from uneducated workers is diminished
                    //  while the number of educated is increased
                    service_scale = PRIMARY_ED_FACTOR;
                    if (worker.fEducation>1.999) {
                        service_scale = UNIVERSITY_ED_FACTOR;
                    }
                    services = services + service_scale;
                }
            }
        }

		if(building.fEletric_Voltage < 0.9 & game.EletricityLevel > 0)
		{
			services = services * NO_POWER_FACTOR;
		}
		if(building.fWater_CurrentDrinkAmount < 0.001 & game.WaterManagement > 0)
		{
			services = services * NO_WATER_FACTOR;
		}
		services_int = services;
		supply = supply + services_int;
	}
	return(supply);
}
//currency: 1 - rubles, 0 - dollars, excess: >0 - export, <0 - import
defineFunction(Price, float, int:currency, int:excess) 
{
	price_inertia = supply + BASE_FOREIGN_SUPPLY_DEMAND + FOREIGN_SUPPLY_DEMAND_FACTOR * population;
	factor = 1.0 - excess / price_inertia;
	if(excess > 0)
	{
		price = factor * (currency * PRICE_SELL_RUB + (1 - currency) * PRICE_SELL_USD) / (100 ^ NUMBER_OF_PRICE_DECREASES);
	}
	else()
	{
		price = factor * (currency * PRICE_BUY_RUB + (1 - currency) * PRICE_BUY_USD) / (100 ^ NUMBER_OF_PRICE_DECREASES);
	}
	return(price);
}
defineFunction(MakePeopleAngry, void, float:unpaid_services)
{
	for(i=0, i<population, i=i+1)
	{
		worker.GetDataByIndex(i);
		Person_SetStatus(i, 0, MaxFloat(worker.fStatusHappiness - unpaid_services * UNHAPPINESS_FACTOR / 20.0, 0.0)) //decrease happiness
		Person_SetStatus(i, 3, MaxFloat(worker.fStatusSoviet - unpaid_services * LOYALTY_FACTOR / 20.0, 0.0)) //decrease loyalty
		if(game.CrimeEnabled > 0)
		{
			Person_SetStatus(i, 10, MinFloat(worker.fStatusCrime + unpaid_services * CRIME_FACTOR / 20.0, 1.0)) //increase crime
		}
	}
	//increased probability of fire
	if(FIRE_PROB_DENOMINATOR > 0 % game.FiresEnabled > 0) 
	{
		Random(random_is_fire);
		random_is_fire = random_is_fire % FIRE_PROB_DENOMINATOR;
		if(random_is_fire ? 1)
		{
			Random(random_building_id);
			random_building_id = random_building_id % n;
			building.GetDataByIndex(random_building_id);
			vector = building.vPosition;
			if(building.fPercFinished > 0.9999)
			{
				Building_StartFire(random_building_id);
				Notification_CreateNewStringPic(
				"Insufficient services",
				"Lack of overseeing has led to an incident in one of our buildings. The building is on fire.",
				"services_icon.png",
				vector);
			}
		}
	}
	returnVoid();
}
defineFunction(Money, void, float:rub, float:usd)
{
	InitConstants();
	InitSettings();
    NEWLINE = 10; // ASCII LF
	//check correctness of the constants in the settings file
	INFLATION_RUB = MaxFloat(INFLATION_RUB, 1.0);
	INFLATION_USD = MaxFloat(INFLATION_USD, 1.0);
	PRICE_BUY_RUB = MaxFloat(PRICE_BUY_RUB, 0.0);
	PRICE_BUY_USD = MaxFloat(PRICE_BUY_USD, 0.0);
	PRICE_SELL_RUB = MaxFloat(PRICE_SELL_RUB, 0.0);
	PRICE_SELL_USD = MaxFloat(PRICE_SELL_USD, 0.0);
	FOREIGN_SUPPLY_DEMAND_FACTOR = MaxFloat(FOREIGN_SUPPLY_DEMAND_FACTOR, 0.0);
	PRIMARY_ED_FACTOR = MaxFloat(PRIMARY_ED_FACTOR, 0.0);
	UNIVERSITY_ED_FACTOR = MaxFloat(UNIVERSITY_ED_FACTOR, 0.0);
	year = START_YEAR;
	rub_sum = 0;
	usd_sum = 0;
	Script_GetGameTime(game_time);
	Script_GetGameTime(game_time_prev);
	
	//deduce the start year
	if(START_YEAR ? 0)
	{
		Date_GetCurrentDate_D365Y(day, year);
		i=1799;
		while(i<year+1 & START_YEAR ? 0)
		{
			stat_record.GetFromDateToDate_D365Y(0, i, 0, i+1);
			value = stat_record.Vehicles_ImportUSD + stat_record.Vehicles_ImportRUB + stat_record.ImportTonsRUB.gravel + stat_record.ImportTonsUSD.gravel;
			if(value > 0)
			{
				START_YEAR = i;
			}
			i=i+1;
		}
		if(START_YEAR ? 0)
		{	
			START_YEAR = year;
		}
		//strcpy(text, START_YEAR);
		//Window_ShowCharArray(text);
	}
	//random_is_fire = game.FiresEnabled;
	//strcpy(text, random_is_fire);
	//Window_ShowCharArray(text);
	while (1 ? 1)
	{
		game.GetCurrentGameSettigns();
		rub_sum2 = 0;
		usd_sum2 = 0;
		clicked_object_id = -1;
		Date_GetCurrentDate_D365Y(current_day, year);
		Date_GetCurrentDate_D365Y(processing_day, year);
		while(current_day ? processing_day)
		{
		    Script_EnterCriticalSection();
			Date_GetCurrentDate_D365Y(current_day, year);
			Script_GetGameTime(game_time);
			if(game_time - game_time_prev > 2.5)
			{
				//Script_EnterCriticalSection();
				time_factor = (game_time - game_time_prev) / 60.0;
				Building_GetNumberOfBuildings(n);
				Money_GetRUB(money_rub);
				Money_GetUSD(money_usd);

				demand_total_vehicles = 0;
				if (VEHICLE_DIFFICULTY > 0.0)
                {
                    demand_total_vehicles = 0 + CalculateVehicleDemand();
                }

				demand_total_civics = CalculateCivicDemand();
                demand_total = demand_total_civics + demand_total_vehicles;

				supply = CalculateSupply();
				difference = supply - demand_total;

				difference = difference * time_factor;

                // Grow the cache if supply or demand is a historic high
			    if (supply * SUPPLY_CACHE_DAYS > supply_cache_capacity)
			    {
			        supply_cache_capacity = supply * SUPPLY_CACHE_DAYS;
			    }
			    if (demand_total * SUPPLY_CACHE_DAYS > supply_cache_capacity)
			    {
			        supply_cache_capacity = demand_total * SUPPLY_CACHE_DAYS;
			    }

                // Determine how the service cache should be used
				supply_cache = supply_cache + difference;

				if(supply_cache > supply_cache_capacity)
                {
                    difference = supply_cache - supply_cache_capacity;
                    supply_cache = supply_cache_capacity;
                }
                elseif(supply_cache < 0)
                {
                    difference = supply_cache;
                    supply_cache = 0;
                }
                else()
                {
                    // All transactions completed using the cache. No trade needed.
                    difference = 0;
                }

                // Use the cache to store the decimal values that would have been lost in the float to int truncation.
                // Note: The function 'ModuleInt' is used as a bodge to force a truncation without adding a variable.
                // It returns the absolute value, so the sign must be accounted for.
                if (difference > 0)
                {
                    // TODO: Test this section
                    supply_cache = supply_cache + difference - ModuleInt(difference);  // Add the fractional part to the supply cache
                    difference = ModuleInt(difference);  // Keep only the integer part for further calculations
                }
                elseif (difference < 0)
                {
                    supply_cache = supply_cache + difference + ModuleInt(difference);  // Add the fractional part to the supply cache
                    difference = 0 - ModuleInt(difference);  // Keep only the integer part for further calculations
                }

                if (supply_cache < 0)
                {
                    supply_cache = supply_cache + 1;
                    difference = difference - 1;
                }

				current_price_rub = ScaledRUB(Price(1, difference));
				current_price_usd = ScaledUSD(Price(0, difference));
				money_rub_add = MaxFloat(difference, 0.0) * rub * current_price_rub;
				money_usd_add = MaxFloat(difference, 0.0) * usd * current_price_usd;
				money_rub_add = money_rub_add - MaxFloat(-difference, 0.0) * rub * current_price_rub;
				money_usd_add = money_usd_add - MaxFloat(-difference, 0.0) * usd * current_price_usd;
				if (-1.0 * money_rub_add < MaxInt(money_rub, 0) & CAN_IMPORT_SERVICES > 0)
				{
					Money_AddRUB(money_rub_add);
				}
				elseif(rub > 0.0)
				{
					MakePeopleAngry(rub * ModuleFloat(difference * 1.0 / demand_total));
				}
				if (-1.0 * money_usd_add < MaxInt(money_usd, 0) & CAN_IMPORT_SERVICES > 0)
				{
					Money_AddUSD(money_usd_add);
				}
				elseif(usd > 0.0)
				{
					MakePeopleAngry(usd * ModuleFloat(difference * 1.0 / demand_total));
				}
				rub_sum2 = rub_sum2 + money_rub_add;
				usd_sum2 = usd_sum2 + money_usd_add;

				// User Interface
				difference = supply - demand_total; // Rescale for full day

				Objective_Remove("services");
				Objective_Remove("service_price");
				Objective_Remove("services_balance");
				Window_GetLastWindow(window_id);
				if(window_id ? -1)
				{
					clicked_object_id = -1;
				}
				else()
				{
					window.GetDataByIndex(window_id);
					if (window.nValidRead)
					{
						if (window.nReferenceObjectType ? SOVIET_OBJECT_BUILDING & !(clicked_object_id ? window.nRefObjectIndex))
						{
							clicked_object_id = window.nRefObjectIndex;
							if(window.nReferenceObjectType ? SOVIET_OBJECT_BUILDING)
							{
								building.GetDataByIndex(clicked_object_id);
								Scenario_WindowExists(window_exists);
								if(building.nType ? BUILDINGTYPE_CITYHALL & building.fPercFinished > 0.9999 & ! (building.nSubType ? BUILDINGSUBTYPE_ROAD) & !window_exists)
								{
									strcpy(text, "");

									strcat(text, "Supply Cache: ");
									strcat(text, supply_cache);
									strcat(text, " / ");
									strcat(text, supply_cache_capacity);
									strcat(text, NEWLINE);

									strcat(text, "Time Factor: ");
									time_factor = time_factor * 1000.0;
									strcat(text, time_factor);
									strcat(text, NEWLINE);

									strcat(text, "Service trade: ");
									if (difference < 0 & CAN_IMPORT_SERVICES > 0)
									{
									    strcat(text, "Deficit of ");
									    difference = -difference;
									    strcat(text, difference);
									    difference = -difference;
									}
									elseif(difference ? 0)
								    {
								        strcat(text, " None. Using the cache.");
								    }
									else()
									{
									    strcat(text, "Surplus of ");
									    strcat(text, difference);
									}
									strcat(text, NEWLINE);

									strcat(text, NEWLINE);
									strcat(text, "=== Service Production ===");
									strcat(text, NEWLINE);
									
									strcat(text, "Services produced: ");
									strcat(text, supply);
									strcat(text, NEWLINE);


									strcat(text, NEWLINE);
									strcat(text, "=== Service Consumption ===");
									strcat(text, NEWLINE);

									strcat(text, "Total Services needed: ");
									strcat(text, demand_total);
									strcat(text, NEWLINE);

									strcat(text, "Civic Services needed: ");
									strcat(text, demand_total_civics);
									strcat(text, NEWLINE);

									strcat(text, "Vehicle Services needed: ");
									strcat(text, demand_total_vehicles);
									strcat(text, NEWLINE);


									strcat(text, NEWLINE);
									strcat(text, "=== Service Market ===");
									strcat(text, NEWLINE);
									
									strcat(text, "Services price (rubles): ");
									strcat(text, current_price_rub);
									strcat(text, NEWLINE);
									
									strcat(text, "Services price (dollars): ");
									strcat(text, current_price_usd);
									strcat(text, NEWLINE);
									
									strcat(text, "Last day balance (rubles): ");
									strcat(text, rub_sum);
									strcat(text, NEWLINE);
									
									strcat(text, "Last day balance (dollars): ");
									strcat(text, usd_sum);
									strcat(text, NEWLINE);

									strcat(text, "Instant market spend (rubles): ");
									strcat(text, money_rub_add);
									strcat(text, NEWLINE);
									
									Scenario_WindowWithImageLeft("Services overview", text, "services_icon.png", 2);
								}
							}
						}
					}
				}
				if(INFORMATION_SHOWN > 0)
				{
					if(INTERNAL_DEMAND_FACTOR > 0.0 & INFORMATION_SHOWN > 1)
					{
						//show the internal supply and demand for services
						Objectives_CreateNewString("services", "Services");
						Objective_AddRequirement("services", demand_total * 1.0, "services_icon.png");
						Objective_UpdateRequirement("services", 0, supply * 1.0);
					}
					if(INFORMATION_SHOWN > 1 & CAN_IMPORT_SERVICES > 0)
					{
						//show the service market price
						Objectives_CreateNewString("service_price", "Current service price");
						Objective_AddRequirement("service_price", 0.0, "editor/currency_ruble.png");
						Objective_UpdateRequirement("service_price", 0, current_price_rub);
						Objective_AddRequirement("service_price", 0.0, "editor/currency_dollar.png");
						Objective_UpdateRequirement("service_price", 1, current_price_usd);
					}
					//show the services balance last day
					Objectives_CreateNewString("services_balance", "Daily services balance");
					Objective_AddRequirement("services_balance", 0.0, "editor/currency_ruble.png");
					Objective_UpdateRequirement("services_balance", 0, rub_sum * 1.0);
					Objective_AddRequirement("services_balance", 0.0, "editor/currency_dollar.png");
					Objective_UpdateRequirement("services_balance", 1, usd_sum * 1.0);
				}
				game_time_prev = game_time;
				//Script_LeaveCriticalSection();
			}

		    Script_LeaveCriticalSection();
		}
		rub_sum = rub_sum2;
		usd_sum = usd_sum2;
		Script_Sleep(0.1);
	}
	returnVoid();
}
